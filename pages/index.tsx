import Head from "next/head";
import Image from "next/image";
import { useEffect, useState } from "react";
import styles from "../styles/Home.module.css";
import { PublicKey } from "@solana/web3.js";
// @ts-ignore
import * as prb from "pseudo-random-buffer";

import { motion, MotionConfig, useAnimationFrame } from "framer-motion";
import { Canvas, useFrame } from "@react-three/fiber";
import { Box, Line, OrbitControls, Stats } from "@react-three/drei";

const x = 10;
const y = 10;
const z = 10;

type DisplayEncoding = "utf8" | "hex";
type PhantomEvent = "disconnect" | "connect" | "accountChanged";
type PhantomRequestMethod = "connect" | "disconnect";

interface ConnectOpts {
  onlyIfTrusted: boolean;
}

interface PhantomProvider {
  publicKey: PublicKey | null;
  isConnected: boolean | null;
  connect: (opts?: Partial<ConnectOpts>) => Promise<{ publicKey: PublicKey }>;
  disconnect: () => Promise<void>;
  on: (event: PhantomEvent, handler: (args: any) => void) => void;
  request: (method: PhantomRequestMethod, params: any) => Promise<unknown>;
}

const getProvider = (): PhantomProvider | undefined => {
  if ("solana" in window) {
    // @ts-ignore
    const provider = window.solana as any;
    if (provider.isPhantom) return provider as PhantomProvider;
  }
};

export default function Home() {
  const [gameState, setGameState] = useState([true]);
  const [gameStateArray, setGameStateArray] = useState<boolean[][]>([]);

  const [walletAddress, setWalletAddress] = useState("");
  const [provider, setProvider] = useState<PhantomProvider | undefined>(
    undefined
  );
  useEffect(() => {
    setGameStateArray([]);
    const gameStateArr = [];
    if (walletAddress != "") {
      let newGameState = generateGameFrame(walletAddress, 0);
      gameStateArr.push(newGameState);
      console.log(newGameState);
      // setGameStateArray((oldArray) => [...oldArray, newGameState]);
      for (let i = 0; i < z - 1; i++) {
        newGameState = generateNextGameFrame(newGameState);
        gameStateArr.push(newGameState);
        // setGameStateArray((oldArray) => [...oldArray, newGameState]);
        console.log(newGameState);
      }
      setGameStateArray(gameStateArr);
      console.log("this", gameStateArr);
    }
  }, [walletAddress]);

  useEffect(() => {
    const provider = getProvider();

    if (provider) setProvider(provider);
    else setProvider(undefined);
  }, []);

  const connectWallet = async () => {
    // @ts-ignore
    const { solana } = window;

    if (solana) {
      try {
        const response = await solana.connect();
        console.log("wallet account ", response.publicKey.toString());
        setWalletAddress(response.publicKey.toString());
      } catch (err) {
        // { code: 4001, message: 'User rejected the request.' }
      }
    }
  };

  const disconnectWallet = async () => {
    // @ts-ignore
    const { solana } = window;

    if (walletAddress && solana) {
      await (solana as PhantomProvider).disconnect();
      setWalletAddress("");
    }
  };

  return (
    <div className={styles.container}>
      <Head>
        <title>3d Game Of Life</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        {gameStateArray.length == z ? (
          <>
            <GameBoard
              randomString={walletAddress}
              gameStateArray={gameStateArray}
            ></GameBoard>
            <p>{`Connected Wallet "${walletAddress}"`}</p>
            <motion.p
              style={{ color: "#f00", cursor: "pointer" }}
              onClick={() => disconnectWallet()}
            >
              disconnect
            </motion.p>
          </>
        ) : (
          <>
            {!provider ? (
              <div className={styles.getPhantomWalletContainer}>
                <p>Phantom Wallet not detected</p>
                <a
                  href={"https://phantom.app/"}
                  rel="noreferrer"
                  target={"_blank"}
                >
                  Get Phantom Wallet
                </a>
              </div>
            ) : (
              <motion.div
                whileHover={{ scale: 1.05 }}
                whileTap={{
                  scale: 1,

                  borderRadius: "5px",
                }}
                className={styles.connectPhantomWalletContainer}
              >
                <div onClick={connectWallet}>Connect to Phantom Wallet</div>
              </motion.div>
            )}
          </>
        )}
      </main>
    </div>
  );
}

function GameBoard(props: any) {
  const [game3dStateMatrix, setGame3dStateMatrix] = useState([[[null]]]);
  const [firstTrue, setFirstTrue] = useState([]);

  useEffect(() => {
    console.log(props.gameStateArray);

    setFirstTrue([]);
    const newGame3dStateMatrix = [];
    const redArr = [];
    for (let i = 0; i < z; i++) {
      const newGameStateMatrix = [];
      for (let j = 0; j < x; j++) {
        const row = [];
        for (let k = 0; k < y; k++) {
          row.push(props.gameStateArray[k][i * x + j]);
          const randomBytes = prb(`${props.randomString}_${i}_${j}_${k}`);
          const randomBuffer = randomBytes(1);
          if (randomBuffer[0] == 1 || randomBuffer[0] == 2) {
            redArr.push(`${i}_${j}_${k}`);
          }
        }
        newGameStateMatrix.push(row);
      }
      newGame3dStateMatrix.push(newGameStateMatrix);
    }
    setGame3dStateMatrix(newGame3dStateMatrix);
    // @ts-ignore
    setFirstTrue(redArr);
    console.log(newGame3dStateMatrix);
  }, [props.gameStateArray]);

  return (
    <motion.div>
      <motion.div className={styles.CanvasContainer}>
        <Canvas>
          <OrbitControls />
          <pointLight intensity={0.5} position={[5, 5, 5]} />
          <pointLight intensity={0.5} position={[-5, -5, -5]} />
          <pointLight intensity={0.5} position={[-5, -5, 5]} />
          <pointLight intensity={0.5} position={[5, 5, -5]} />

          <GameCubes
            game3dStateMatrix={game3dStateMatrix}
            firstTrue={firstTrue}
          ></GameCubes>
          {/* <Stats /> */}
        </Canvas>
      </motion.div>
    </motion.div>
  );
}

function GameCubes(props: any) {
  const [zRotation, setZRotation] = useState(0);

  useFrame(({ clock }) => {
    setZRotation((old) => old + Math.min(0.05, clock.getDelta()));
  });

  return (
    <mesh scale={[0.35, 0.35, 0.35]} rotation={[0, zRotation, 0]}>
      {props.game3dStateMatrix.map((gameStateMatrix: any, i: number) => {
        return gameStateMatrix.map((row: any, j: number) => {
          return row.map((cell: any, k: number) => {
            return (
              <mesh
                key={`${i - 5}-${j - 5}-${k - 5}`}
                position={[k - 5, j - 5, i - 5]}
              >
                {cell ? (
                  <Box position={[0.5, 0.5, 0.5]} scale={[0.8, 0.8, 0.8]}>
                    <meshPhongMaterial
                      color={
                        // @ts-ignore
                        props.firstTrue.indexOf(`${i}_${j}_${k}`) != -1
                          ? "red"
                          : "white"
                      }
                      opacity={0.9}
                      transparent
                      // roughness={1}
                    ></meshPhongMaterial>
                  </Box>
                ) : (
                  <></>
                )}
              </mesh>
            );
          });
        });
      })}
    </mesh>
  );
}

function generateGameFrame(randomString: string, frameNumber: number) {
  const numberOfBlocks = x * y;
  const numberOfBitsNeeded = numberOfBlocks * 2;
  const numberOfBytesNeeded = Math.ceil(numberOfBitsNeeded / 8);
  const randomBytes = prb(randomString + frameNumber.toString());
  const randomBuffer = randomBytes(numberOfBytesNeeded);
  const newGameState = [];
  console.log(numberOfBlocks);
  for (let i = 0; i < numberOfBlocks; i++) {
    const bit1 = getBitFromBuffer(i * 2, randomBuffer);
    const bit2 = getBitFromBuffer(i * 2 + 1, randomBuffer);
    if (bit1 && bit2) {
      newGameState.push(true);
    } else {
      newGameState.push(false);
    }
  }
  return newGameState;
}

function generateNextGameFrame(currentGameState: any) {
  const nextGeneration = new Array(x * y);
  for (let i = 0; i < x; i++) {
    for (let j = 0; j < y; j++) {
      const numberOfNeighbors = getNumberOfNeighbors(currentGameState, i, j);
      const cell = currentGameState[(j - 1) * x + i];
      if (cell) {
        if (numberOfNeighbors < 2 || numberOfNeighbors > 3) {
          nextGeneration[(j - 1) * x + i] = false;
        } else {
          nextGeneration[(j - 1) * x + i] = true;
        }
      } else {
        if (numberOfNeighbors === 3) {
          nextGeneration[(j - 1) * x + i] = true;
        } else {
          nextGeneration[(j - 1) * x + i] = false;
        }
      }
    }
  }
  return nextGeneration;
}

function getNumberOfNeighbors(
  currentGameState: boolean[],
  l: number,
  m: number
) {
  let aliveNeighbours = 0;
  for (let i = -1; i < 2; i++) {
    for (let j = -1; j < 2; j++) {
      if (l + i >= 0 && l + i < x && m + j >= 0 && m + j < y)
        aliveNeighbours += currentGameState[(m + j - 1) * x + l + i] ? 1 : 0;
    }
  }
  return aliveNeighbours;
}

function getBitFromBuffer(bitIndex: number, bufferObj: Buffer) {
  const byte = ~~(bitIndex / 8); // which byte to look at
  const bit = bitIndex % 8; // which bit within the byte to look at
  const idByte = bufferObj[byte]; // grab the byte from the buffer
  if (idByte & Math.pow(2, 7 - bit)) {
    return true;
  } // check that the bit is set
  else {
    return false;
  } // otherwise, the bit is not set
}

// TODO try clear coat meterial property.
