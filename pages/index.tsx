import Head from "next/head";
import Image from "next/image";
import { useEffect, useState } from "react";
import styles from "../styles/Home.module.css";

import * as prb from "pseudo-random-buffer";

import { motion, MotionConfig, useAnimationFrame } from "framer-motion";
import { Canvas, useFrame } from "@react-three/fiber";
import { Box, Line, OrbitControls } from "@react-three/drei";

const randomString = "Hello World!";
const x = 10;
const y = 10;
const z = 10;

export default function Home() {
  const [gameState, setGameState] = useState([true]);
  const [gameStateArray, setGameStateArray] = useState<boolean[][]>([]);
  useEffect(() => {
    setGameStateArray([]);
    for (let i = 0; i < z; i++) {
      const newGameState = generateGameFrame(randomString, i);
      setGameStateArray((oldArray) => [...oldArray, newGameState]);
    }
    console.log("this", gameStateArray);
  }, []);

  return (
    <div className={styles.container}>
      <Head>
        <title>3d Game Of Life</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        {gameStateArray.length == z ? (
          <>
            <GameBoard gameStateArray={gameStateArray}></GameBoard>
            <p>{`Random Seed "${randomString}"`}</p>
          </>
        ) : (
          "Loading Frames..."
        )}
      </main>
    </div>
  );
}

function GameBoard(props: any) {
  const [game3dStateMatrix, setGame3dStateMatrix] = useState([[[null]]]);
  const [firstTrue, setFirstTrue] = useState([]);
  const [zRotation, setZRotation] = useState(0);

  useEffect(() => {
    setFirstTrue([]);
    const newGame3dStateMatrix = [];
    const redArr = [];
    for (let i = 0; i < z; i++) {
      const newGameStateMatrix = [];
      for (let j = 0; j < x; j++) {
        const row = [];
        for (let k = 0; k < y; k++) {
          row.push(props.gameStateArray[i][j * x + k]);
          const randomBytes = prb(`${randomString}_${i}_${j}_${k}`);
          const randomBuffer = randomBytes(1);
          if (randomBuffer[0] == 1 || randomBuffer[0] == 2) {
            redArr.push(`${i}_${j}_${k}`);
          }
        }
        newGameStateMatrix.push(row);
      }
      newGame3dStateMatrix.push(newGameStateMatrix);
    }
    setGame3dStateMatrix(newGame3dStateMatrix);
    // @ts-ignore
    setFirstTrue(redArr);
    console.log(newGame3dStateMatrix);
  }, [props.gameStateArray]);

  useAnimationFrame(() => {
    setZRotation((old) => old + 0.01);
  });

  return (
    <motion.div>
      <motion.div className={styles.CanvasContainer}>
        <Canvas>
          <OrbitControls />
          <pointLight intensity={0.3} position={[10, 10, 10]} />
          <pointLight intensity={0.3} position={[-10, -10, -10]} />
          <pointLight intensity={0.3} position={[-10, -10, 10]} />
          <pointLight intensity={0.3} position={[10, 10, -10]} />

          <mesh scale={[0.35, 0.35, 0.35]} rotation={[0, zRotation, 0]}>
            {game3dStateMatrix.map((gameStateMatrix, i) => {
              return gameStateMatrix.map((row, j) => {
                return row.map((cell, k) => {
                  return (
                    <mesh
                      key={`${i - 5}-${j - 5}-${k - 5}`}
                      position={[i - 5, j - 5, k - 5]}
                    >
                      {/* <boxGeometry />
                      <meshPhongMaterial
                        color={cell ? "white" : "white"}
                        opacity={cell ? 0.5 : 0}
                        transparent
                      /> */}

                      {/* Box Form Lines */}
                      {/* @ts-ignore */}
                      {/* <Line
                        points={[
                          [0, 0, 0],
                          [1, 0, 0],
                          [1, 1, 0],
                          [0, 1, 0],
                          [0, 0, 0],
                          [0, 0, 1],
                          [1, 0, 1],
                          [1, 1, 1],
                          [0, 1, 1],
                          [0, 0, 1],
                          [0, 0, 0],
                          [0, 0, 1],
                          [0, 1, 1],
                          [0, 1, 0],
                          [0, 0, 0],
                          [1, 0, 0],
                          [1, 0, 1],
                          [1, 1, 1],
                          [1, 1, 0],
                          [1, 0, 0],
                        ]}
                        color="white"
                        opacity={0.5}
                      ></Line> */}
                      {cell ? (
                        <Box position={[0.5, 0.5, 0.5]} scale={[0.8, 0.8, 0.8]}>
                          <meshPhysicalMaterial
                            color={
                              // @ts-ignore
                              firstTrue.indexOf(`${i}_${j}_${k}`) != -1
                                ? "red"
                                : "white"
                            }
                            opacity={0.9}
                            transparent
                            roughness={1}
                            metalness={0}
                          ></meshPhysicalMaterial>
                        </Box>
                      ) : (
                        <></>
                      )}
                    </mesh>
                  );
                });
              });
            })}
          </mesh>
        </Canvas>
      </motion.div>
    </motion.div>
  );
}

function generateGameFrame(randomString: string, frameNumber: number) {
  const numberOfBlocks = x * y;
  const numberOfBitsNeeded = numberOfBlocks * 2;
  const numberOfBytesNeeded = Math.ceil(numberOfBitsNeeded / 8);
  const randomBytes = prb(randomString + frameNumber.toString());
  const randomBuffer = randomBytes(numberOfBytesNeeded);
  const newGameState = [];
  console.log(numberOfBlocks);
  for (let i = 0; i < numberOfBlocks; i++) {
    const bit1 = getBitFromBuffer(i * 2, randomBuffer);
    const bit2 = getBitFromBuffer(i * 2 + 1, randomBuffer);
    if (bit1 && bit2) {
      newGameState.push(true);
    } else {
      newGameState.push(false);
    }
  }
  return newGameState;
}

function getBitFromBuffer(bitIndex: number, bufferObj: Buffer) {
  const byte = ~~(bitIndex / 8); // which byte to look at
  const bit = bitIndex % 8; // which bit within the byte to look at
  const idByte = bufferObj[byte]; // grab the byte from the buffer
  if (idByte & Math.pow(2, 7 - bit)) {
    return true;
  } // check that the bit is set
  else {
    return false;
  } // otherwise, the bit is not set
}
